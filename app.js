// Traduções para português brasileiro
const objectTranslations = {
  // COCO-SSD (80 classes)
  person: "pessoa",
  bicycle: "bicicleta",
  car: "carro",
  motorcycle: "motocicleta",
  airplane: "avião",
  bus: "ônibus",
  train: "trem",
  truck: "caminhão",
  boat: "barco",
  "traffic light": "semáforo",
  "fire hydrant": "hidrante",
  "stop sign": "placa de pare",
  "parking meter": "parquímetro",
  bench: "banco",
  bird: "pássaro",
  cat: "gato",
  dog: "cachorro",
  horse: "cavalo",
  sheep: "ovelha",
  cow: "vaca",
  elephant: "elefante",
  bear: "urso",
  zebra: "zebra",
  giraffe: "girafa",
  backpack: "mochila",
  umbrella: "guarda-chuva",
  handbag: "bolsa",
  tie: "gravata",
  suitcase: "mala",
  frisbee: "frisbee",
  skis: "esquis",
  snowboard: "snowboard",
  "sports ball": "bola esportiva",
  kite: "pipa",
  "baseball bat": "taco de baseball",
  "baseball glove": "luva de baseball",
  skateboard: "skate",
  surfboard: "prancha de surf",
  "tennis racket": "raquete de tênis",
  bottle: "garrafa",
  "wine glass": "taça de vinho",
  cup: "xícara",
  fork: "garfo",
  knife: "faca",
  spoon: "colher",
  bowl: "tigela",
  banana: "banana",
  apple: "maçã",
  sandwich: "sanduíche",
  orange: "laranja",
  broccoli: "brócolis",
  carrot: "cenoura",
  "hot dog": "cachorro-quente",
  pizza: "pizza",
  donut: "rosquinha",
  cake: "bolo",
  chair: "cadeira",
  couch: "sofá",
  "potted plant": "vaso de planta",
  bed: "cama",
  "dining table": "mesa de jantar",
  toilet: "vaso sanitário",
  tv: "televisão",
  laptop: "notebook",
  mouse: "mouse",
  remote: "controle remoto",
  keyboard: "teclado",
  "cell phone": "celular",
  microwave: "micro-ondas",
  oven: "forno",
  toaster: "torradeira",
  sink: "pia",
  refrigerator: "geladeira",
  book: "livro",
  clock: "relógio",
  vase: "vaso",
  scissors: "tesoura",
  "teddy bear": "ursinho de pelúcia",
  "hair drier": "secador de cabelo",
  toothbrush: "escova de dente",

  // MobileNet classes adicionais (mais comuns)
  "Egyptian cat": "gato egípcio",
  "tabby, tabby cat": "gato rajado",
  "tiger cat": "gato tigrado",
  "Persian cat": "gato persa",
  "Siamese cat": "gato siamês",
  "golden retriever": "golden retriever",
  "Labrador retriever": "labrador",
  "German shepherd": "pastor alemão",
  beagle: "beagle",
  boxer: "boxer",
  bulldog: "bulldog",
  poodle: "poodle",
  Chihuahua: "chihuahua",
  "Yorkshire terrier": "yorkshire terrier",
  "border collie": "border collie",
  husky: "husky",
  rottweiler: "rottweiler",
  dalmatian: "dálmata",
  pug: "pug",
  "cocker spaniel": "cocker spaniel",
  "sports car": "carro esportivo",
  convertible: "conversível",
  limousine: "limusine",
  jeep: "jipe",
  minivan: "minivan",
  "pickup truck": "caminhonete",
  ambulance: "ambulância",
  "fire engine": "caminhão de bombeiros",
  "police van": "viatura policial",
  "school bus": "ônibus escolar",
  trolleybus: "ônibus elétrico",
  "moving van": "caminhão de mudança",
  "garbage truck": "caminhão de lixo",
  "tow truck": "guincho",
  "recreational vehicle": "trailer",
  airliner: "avião comercial",
  warplane: "avião de guerra",
  fighter: "caça",
  bomber: "bombardeiro",
  helicopter: "helicóptero",
  "hot air balloon": "balão de ar quente",
  airship: "dirigível",
  glider: "planador",
  parachute: "paraquedas",
  "space shuttle": "ônibus espacial",
  speedboat: "lancha",
  gondola: "gôndola",
  sailboat: "veleiro",
  catamaran: "catamarã",
  yacht: "iate",
  "container ship": "navio cargueiro",
  liner: "transatlântico",
  pirate: "navio pirata",
  "aircraft carrier": "porta-aviões",
  submarine: "submarino",
  wreck: "naufrágio",
  "half track": "semi-lagarta",
  tank: "tanque",
  missile: "míssil",
  bobsled: "bobsled",
  dogsled: "trenó de cachorro",
  "bicycle-built-for-two": "bicicleta dupla",
  "mountain bike": "mountain bike",
  "freight car": "vagão de carga",
  "passenger car": "vagão de passageiros",
  barrow: "carrinho de mão",
  "shopping cart": "carrinho de compras",
  "motor scooter": "scooter",
  forklift: "empilhadeira",
  "electric locomotive": "locomotiva elétrica",
  "steam locomotive": "locomotiva a vapor",
  amphibian: "anfíbio",
  "Model T": "Ford Modelo T",
  racer: "carro de corrida",
  "beach wagon": "perua",
  cab: "táxi",
  taxicab: "táxi",
  "desktop computer": "computador desktop",
  laptop: "laptop",
  tablet: "tablet",
  smartphone: "smartphone",
  iPod: "iPod",
  "web site": "site web",
  "comic book": "história em quadrinhos",
  "crossword puzzle": "palavras cruzadas",
  "street sign": "placa de rua",
  menu: "cardápio",
  plate: "prato",
  guacamole: "guacamole",
  consomme: "consomê",
  "hot pot": "panela quente",
  trifle: "pavê",
  "ice cream": "sorvete",
  "ice lolly": "picolé",
  "French loaf": "baguete",
  bagel: "bagel",
  pretzel: "pretzel",
  cheeseburger: "cheeseburger",
  hotdog: "cachorro-quente",
  "mashed potato": "purê de batata",
  "head cabbage": "repolho",
  artichoke: "alcachofra",
  "bell pepper": "pimentão",
  cardoon: "cardo",
  mushroom: "cogumelo",
  "Granny Smith": "maçã verde",
  strawberry: "morango",
  lemon: "limão",
  fig: "figo",
  pineapple: "abacaxi",
  corn: "milho",
  acorn: "bolota",
  hip: "quadril",
  buckeye: "castanha",
  "coral fungus": "fungo coral",
  agaric: "cogumelo agaric",
  gyromitra: "gyromitra",
  stinkhorn: "falo fedorento",
  earthstar: "estrela da terra",
  "hen-of-the-woods": "maitake",
  bolete: "boleto",
  ear: "orelha",
  "toilet tissue": "papel higiênico",
  cassette: "fita cassete",
  "chain saw": "motosserra",
  church: "igreja",
  palace: "palácio",
  monastery: "mosteiro",
  library: "biblioteca",
  apiary: "apiário",
  boathouse: "casa de barcos",
  barbershop: "barbearia",
  bookshop: "livraria",
  "butcher shop": "açougue",
  confectionery: "confeitaria",
  "shoe shop": "sapataria",
  "tobacco shop": "tabacaria",
  toyshop: "loja de brinquedos",
  fountain: "fonte",
  cliff: "penhasco",
  "coral reef": "recife de coral",
  lakeside: "beira do lago",
  promontory: "promontório",
  sandbar: "banco de areia",
  seashore: "litoral",
  valley: "vale",
  volcano: "vulcão",
  ballpoint: "caneta esferográfica",
  crayon: "giz de cera",
  "felt tip pen": "caneta hidrocor",
  "fountain pen": "caneta tinteiro",
  "pencil box": "estojo",
  "pencil sharpener": "apontador",
  quill: "pena de escrever",
  "rubber eraser": "borracha",
  "paper towel": "papel toalha",
  "facial tissue": "lenço de papel",
  diaper: "fralda",
  "running shoe": "tênis de corrida",
  loafer: "mocassim",
  sandal: "sandália",
  clog: "tamanco",
  "cowboy boot": "bota de cowboy",
  "hiking boot": "bota de trilha",
  "rubber boot": "bota de borracha",
  "ski boot": "bota de esqui",
  snowshoe: "raquete de neve",
  sock: "meia",
  hosiery: "meia-calça",
  miniskirt: "minissaia",
  jean: "jeans",
  cardigan: "cardigã",
  sweater: "suéter",
  sweatshirt: "moletom",
  suit: "terno",
  dress: "vestido",
  kimono: "quimono",
  abaya: "abaya",
  "academic gown": "beca",
  bikini: "biquíni",
  brassiere: "sutiã",
  cloak: "capa",
  "fur coat": "casaco de pele",
  "lab coat": "jaleco",
  raincoat: "capa de chuva",
  "trench coat": "sobretudo",
  poncho: "poncho",
  robe: "roupão",
  apron: "avental",
  "T-shirt": "camiseta",
  jersey: "camisa",
  "Christmas stocking": "meia de Natal",
  "bolo tie": "gravata bolo",
  "bow tie": "gravata borboleta",
  necktie: "gravata",
  scarf: "cachecol",
  stole: "estola",
  "feather boa": "boa de plumas",
  bearskin: "pele de urso",
  bonnet: "touca",
  "cowboy hat": "chapéu de cowboy",
  sombrero: "sombrero",
  "shower cap": "touca de banho",
  "swimming cap": "touca de natação",
  beret: "boina",
  "baseball cap": "boné",
  "football helmet": "capacete de futebol americano",
  "crash helmet": "capacete",
  "hard hat": "capacete de segurança",
  "bathing cap": "touca de banho",
}

// Variáveis globais
let cocoModel = null
let mobilenetModel = null
let currentModel = "coco-ssd"
let isLoading = false

// Elementos DOM
const elements = {
  loadingIndicator: document.getElementById("loadingIndicator"),
  cocoBtn: document.getElementById("cocoBtn"),
  mobilenetBtn: document.getElementById("mobilenetBtn"),
  modelInfo: document.getElementById("modelInfo"),
  modelInfoText: document.getElementById("modelInfoText"),
  uploadArea: document.getElementById("uploadArea"),
  fileInput: document.getElementById("fileInput"),
  imageContainer: document.getElementById("imageContainer"),
  uploadedImage: document.getElementById("uploadedImage"),
  detectionCanvas: document.getElementById("detectionCanvas"),
  analyzeBtn: document.getElementById("analyzeBtn"),
  analyzeBtnText: document.getElementById("analyzeBtnText"),
  resultsTitle: document.getElementById("resultsTitle"),
  processingTime: document.getElementById("processingTime"),
  processingTimeText: document.getElementById("processingTimeText"),
  resultsContainer: document.getElementById("resultsContainer"),
}

// Inicialização
document.addEventListener("DOMContentLoaded", async () => {
  await loadModels()
  setupEventListeners()
})

// Carregar modelos
async function loadModels() {
  try {
    console.log("Carregando modelos...")

    // Importar os modelos dinamicamente
    const [cocoSsd, mobilenet] = await Promise.all([
      (cocoSsd = await cocoSsd.load()),
      (mobilenet = await mobilenet.load()),
    ])

    cocoModel = cocoSsd
    mobilenetModel = mobilenet

    elements.loadingIndicator.classList.add("hidden")
    console.log("Modelos carregados com sucesso!")
  } catch (error) {
    console.error("Erro ao carregar modelos:", error)
    alert("Erro ao carregar os modelos de IA. Recarregue a página.")
  }
}

// Configurar event listeners
function setupEventListeners() {
  // Seletores de modelo
  elements.cocoBtn.addEventListener("click", () => switchModel("coco-ssd"))
  elements.mobilenetBtn.addEventListener("click", () => switchModel("mobilenet"))

  // Upload de arquivo
  elements.uploadArea.addEventListener("click", () => elements.fileInput.click())
  elements.fileInput.addEventListener("change", handleFileUpload)

  // Botão de análise
  elements.analyzeBtn.addEventListener("click", analyzeImage)

  // Drag and drop
  elements.uploadArea.addEventListener("dragover", (e) => {
    e.preventDefault()
    elements.uploadArea.style.borderColor = "#00d4ff"
  })

  elements.uploadArea.addEventListener("dragleave", (e) => {
    e.preventDefault()
    elements.uploadArea.style.borderColor = "rgba(0, 212, 255, 0.5)"
  })

  elements.uploadArea.addEventListener("drop", (e) => {
    e.preventDefault()
    elements.uploadArea.style.borderColor = "rgba(0, 212, 255, 0.5)"

    const files = e.dataTransfer.files
    if (files.length > 0 && files[0].type.startsWith("image/")) {
      handleFile(files[0])
    }
  })
}

// Alternar modelo
function switchModel(model) {
  currentModel = model

  // Atualizar botões
  elements.cocoBtn.classList.toggle("active", model === "coco-ssd")
  elements.mobilenetBtn.classList.toggle("active", model === "mobilenet")

  // Atualizar informações
  if (model === "coco-ssd") {
    elements.modelInfoText.textContent = "Modelo: COCO-SSD - 80 objetos do cotidiano"
    elements.analyzeBtnText.textContent = "Detectar Objetos"
    elements.resultsTitle.textContent = "Resultados da Detecção"
  } else {
    elements.modelInfoText.textContent = "Modelo: MobileNet - 1000+ objetos e categorias"
    elements.analyzeBtnText.textContent = "Classificar Imagem"
    elements.resultsTitle.textContent = "Resultados da Classificação"
  }

  // Limpar resultados anteriores
  clearResults()
}

// Manipular upload de arquivo
function handleFileUpload(event) {
  const file = event.target.files[0]
  if (file && file.type.startsWith("image/")) {
    handleFile(file)
  }
}

// Processar arquivo
function handleFile(file) {
  if (file.size > 10 * 1024 * 1024) {
    // 10MB
    alert("Arquivo muito grande. Máximo 10MB.")
    return
  }

  const reader = new FileReader()
  reader.onload = (e) => {
    elements.uploadedImage.src = e.target.result
    elements.imageContainer.style.display = "block"
    clearResults()

    // Configurar canvas quando a imagem carregar
    elements.uploadedImage.onload = () => {
      const canvas = elements.detectionCanvas
      canvas.width = elements.uploadedImage.naturalWidth
      canvas.height = elements.uploadedImage.naturalHeight
    }
  }
  reader.readAsDataURL(file)
}

// Analisar imagem
async function analyzeImage() {
  if (isLoading || !elements.uploadedImage.src) return

  const model = currentModel === "coco-ssd" ? cocoModel : mobilenetModel
  if (!model) {
    alert("Modelo ainda não carregado. Aguarde...")
    return
  }

  setLoading(true)
  const startTime = performance.now()

  try {
    let results

    if (currentModel === "coco-ssd") {
      // Detecção de objetos com COCO-SSD
      results = await model.detect(elements.uploadedImage)
      drawBoundingBoxes(results)
    } else {
      // Classificação com MobileNet
      results = await model.classify(elements.uploadedImage)
      clearCanvas()
    }

    const endTime = performance.now()
    const processingTime = Math.round(endTime - startTime)

    displayResults(results, processingTime)
  } catch (error) {
    console.error("Erro na análise:", error)
    alert("Erro ao analisar a imagem. Tente novamente.")
  } finally {
    setLoading(false)
  }
}

// Definir estado de carregamento
function setLoading(loading) {
  isLoading = loading
  elements.analyzeBtn.disabled = loading

  if (loading) {
    elements.analyzeBtnText.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analisando com IA...'
  } else {
    const text = currentModel === "coco-ssd" ? "Detectar Objetos" : "Classificar Imagem"
    elements.analyzeBtnText.innerHTML = `<i class="fas fa-eye"></i> ${text}`
  }
}

// Desenhar bounding boxes (COCO-SSD)
function drawBoundingBoxes(predictions) {
  const canvas = elements.detectionCanvas
  const ctx = canvas.getContext("2d")

  // Limpar canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height)

  // Cores para diferentes objetos
  const colors = [
    "#ef4444",
    "#06b6d4",
    "#10b981",
    "#f59e0b",
    "#8b5cf6",
    "#ec4899",
    "#14b8a6",
    "#f97316",
    "#6366f1",
    "#059669",
  ]

  predictions.forEach((prediction, index) => {
    const [x, y, width, height] = prediction.bbox
    const color = colors[index % colors.length]

    // Configurar estilo
    ctx.strokeStyle = color
    ctx.lineWidth = 4
    ctx.font = "bold 16px Inter, Arial, sans-serif"

    // Desenhar bounding box
    ctx.strokeRect(x, y, width, height)

    // Preparar label
    const translatedClass = translateObject(prediction.class)
    const confidence = Math.round(prediction.score * 100)
    const label = `${translatedClass} (${confidence}%)`

    // Medir texto
    const textMetrics = ctx.measureText(label)
    const textHeight = 24

    // Desenhar fundo do texto
    ctx.fillStyle = color
    ctx.fillRect(x, y - textHeight, textMetrics.width + 16, textHeight)

    // Desenhar texto
    ctx.fillStyle = "#ffffff"
    ctx.fillText(label, x + 8, y - 6)
  })
}

// Limpar canvas
function clearCanvas() {
  const canvas = elements.detectionCanvas
  const ctx = canvas.getContext("2d")
  ctx.clearRect(0, 0, canvas.width, canvas.height)
}

// Exibir resultados
function displayResults(results, processingTime) {
  // Mostrar tempo de processamento
  elements.processingTimeText.textContent = `Processamento concluído em ${processingTime}ms`
  elements.processingTime.style.display = "flex"

  // Criar HTML dos resultados
  let resultsHTML = ""

  if (results.length > 0) {
    const resultType = currentModel === "coco-ssd" ? "Objetos Detectados" : "Classificações"
    const countText = currentModel === "coco-ssd" ? results.length : `Top ${results.length}`

    resultsHTML = `
            <div class="results-header">
                <h3>${resultType}</h3>
                <span class="results-count">${countText}</span>
            </div>
            <div class="results-list">
        `

    results.forEach((result, index) => {
      const colorClass = `color-${(index % 10) + 1}`
      let name, confidence

      if (currentModel === "coco-ssd") {
        name = translateObject(result.class)
        confidence = Math.round(result.score * 100)
      } else {
        name = translateObject(result.className)
        confidence = Math.round(result.probability * 100)
      }

      resultsHTML += `
                <div class="result-item ${colorClass}">
                    <span class="result-name">${name}</span>
                    <span class="result-confidence">${confidence}%</span>
                </div>
            `
    })

    resultsHTML += "</div>"
  } else {
    resultsHTML = `
            <div class="empty-state">
                <div class="empty-icon">
                    <i class="fas fa-search"></i>
                </div>
                <p class="empty-title">Nenhum objeto detectado</p>
                <p class="empty-subtitle">Tente com uma imagem diferente</p>
            </div>
        `
  }

  elements.resultsContainer.innerHTML = resultsHTML
}

// Limpar resultados
function clearResults() {
  elements.processingTime.style.display = "none"
  elements.resultsContainer.innerHTML = `
        <div class="empty-state">
            <div class="empty-icon">
                <i class="fas fa-camera"></i>
            </div>
            <p class="empty-title">Aguardando análise</p>
            <p class="empty-subtitle">Carregue uma imagem e clique em "${currentModel === "coco-ssd" ? "Detectar Objetos" : "Classificar Imagem"}"</p>
        </div>
    `
  clearCanvas()
}

// Traduzir objeto
function translateObject(objectName) {
  return objectTranslations[objectName] || objectName
}

// Utilitários para debug
window.debugApp = {
  cocoModel: () => cocoModel,
  mobilenetModel: () => mobilenetModel,
  currentModel: () => currentModel,
  translations: objectTranslations,
}
